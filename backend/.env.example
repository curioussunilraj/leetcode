# Gemini API Key - REQUIRED for problem generation
GEMINI_API_KEY="YOUR_GEMINI_API_KEY_HERE"

# Database URL (for SQLAlchemy)
# For SQLite, it will look like: DATABASE_URL="sqlite:///./data/coder_workspace.db"
# The ./data/ path refers to the 'data' directory created at the project root,
# which will be mounted into /app/data in the backend container.
DATABASE_URL="sqlite:///./data/coder_workspace.db"

# Other backend specific configurations can go here
# Example:
# LOG_LEVEL="INFO"
# SECRET_KEY="a_very_secret_key_for_jwt_if_used"
# ALGORITHM="HS256" # for JWT
# ACCESS_TOKEN_EXPIRE_MINUTES=30
DOCKER_TIMEOUT_SECONDS=10 # Max time for docker execution
DOCKER_MEMORY_LIMIT_MB=256 # Max memory for docker execution
DOCKER_BASE_IMAGE_PYTHON="python:3.11-slim" # Base image for Python code execution
DOCKER_BASE_IMAGE_JAVASCRIPT="node:18-slim"   # Base image for JS code execution
DOCKER_BASE_IMAGE_CPP="gcc:latest"        # Base image for C++ code execution
WORKSPACE_DIR_HOST="./workspace_temp" # Temporary directory on host for staging code to be run in Docker
                                     # This should be relative to the backend app root, or an absolute path.
                                     # Let's make it relative to /app inside the container for simplicity.
WORKSPACE_DIR_CONTAINER="/app/workspace_temp"

# Frontend URL (if backend needs to know it, e.g. for CORS)
# FRONTEND_URL="http://localhost:3000"
PYTHON_EXECUTION_FILENAME="solution.py"
JAVASCRIPT_EXECUTION_FILENAME="solution.js"
CPP_EXECUTION_FILENAME="solution.cpp"
CPP_COMPILED_FILENAME="solution_exec"
